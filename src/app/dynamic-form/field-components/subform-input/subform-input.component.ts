import { CdkDragDrop, DragDropModule } from '@angular/cdk/drag-drop';
import { ChangeDetectorRef, Component, computed, inject, OnInit, Type } from '@angular/core';
import { AbstractControl, FormArray, FormBuilder, FormGroup, ReactiveFormsModule, ValidatorFn, Validators } from '@angular/forms';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatDialog, MatDialogModule } from '@angular/material/dialog';
import { MatDividerModule } from '@angular/material/divider';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatIconModule } from '@angular/material/icon';
import { MatListModule } from '@angular/material/list';
import { asyncScheduler, observeOn, of, tap } from 'rxjs';
import { FormConfig, FormField } from '../../../models/form-config.model';
import { BaseFieldComponent, ControlType } from '../base-field.component';
import { FIELD_COMPONENT_VIEW_PROVIDERS } from '../field-component-constants';
import { FieldComponentRegistryService } from '../field-component-registry.service';
import { SubformItemDialogComponent, SubformItemDialogData } from './subform-item-dialog.component';

/**
 * Configuration interface for subform input component.
 * 
 * This interface defines all configuration options for the subform component,
 * including the nested form configuration, item constraints, and UI behavior.
 * 
 * @public
 */
export interface SubformInputConfig {
  /** The form configuration for each subform item */
  formConfig: FormConfig;
  
  /** Minimum number of items required in the array */
  minItems?: number;
  
  /** Maximum number of items allowed in the array */
  maxItems?: number;
  
  /** Label text for the add button */
  addButtonLabel?: string;
  
  /** Label text for the delete button */
  deleteButtonLabel?: string;
  
  /** Function to generate a description string for each item in the list */
  getItemDescription: (formGroup: FormGroup, index: number) => string;
  
  /** Whether deletion of items is allowed. Defaults to true */
  allowDelete?: boolean;
  
  /** Whether to show confirmation dialog before deletion. Defaults to true */
  confirmDelete?: boolean;
  
  /** Custom confirmation message for deletion. Uses default if not provided */
  deleteConfirmationMessage?: string;
  
  /** Whether drag and drop sorting is enabled. Defaults to true */
  allowDragDrop?: boolean;
}

/**
 * Subform input component for managing dynamic arrays of nested forms.
 * 
 * This component renders a FormArray that contains multiple FormGroups, each
 * representing a subform item. It provides functionality for:
 * - Adding new items via modal dialog
 * - Editing existing items via modal dialog
 * - Deleting items with optional confirmation
 * - Drag-and-drop reordering of items
 * - Displaying items as descriptions using a configurable function
 * 
 * The component uses Angular Material Dialog for item editing and Angular CDK
 * Drag and Drop for reordering. Each item is displayed as a description string
 * generated by the `getItemDescription` function.
 * 
 * @example
 * ```typescript
 * {
 *   name: 'addresses',
 *   type: 'subform',
 *   required: true,
 *   label: 'Addresses',
 *   config: {
 *     formConfig: {
 *       name: 'Address Form',
 *       fields: [
 *         { name: 'street', type: 'text', required: true, label: 'Street' },
 *         { name: 'city', type: 'text', required: true, label: 'City' }
 *       ]
 *     },
 *     minItems: 1,
 *     maxItems: 5,
 *     allowDragDrop: true,
 *     getItemDescription: (formGroup, index) => {
 *       const street = formGroup.get('street')?.value || '';
 *       const city = formGroup.get('city')?.value || '';
 *       return `${street}, ${city}`;
 *     }
 *   }
 * }
 * ```
 * 
 * @public
 */
@Component({
  selector: 'app-subform-input',
  standalone: true,
  imports: [
    ReactiveFormsModule,
    DragDropModule,
    MatFormFieldModule,
    MatButtonModule,
    MatIconModule,
    MatCardModule,
    MatDividerModule,
    MatListModule,
    MatDialogModule
  ],
  viewProviders: FIELD_COMPONENT_VIEW_PROVIDERS,
  templateUrl: './subform-input.component.html',
  styleUrls: ['./subform-input.component.css']
})
export class SubformInputComponent extends BaseFieldComponent implements OnInit {
  /** Computed configuration object for this subform input */
  readonly config = computed(() => {
    const fieldConfig = this.field().config || {};
    return fieldConfig as unknown as SubformInputConfig;
  });
  
  private fb = inject(FormBuilder);
  private registry = inject(FieldComponentRegistryService);
  private dialog = inject(MatDialog);
  private cdr = inject(ChangeDetectorRef, { optional: true });

  /**
   * Returns the control type used by this component.
   * 
   * @returns 'array' since this component manages a FormArray
   */
  override getControlType(): ControlType {
    return 'array';
  }

  /**
   * Gets the FormArray control instance.
   * 
   * @returns The FormArray control, or null if the control is not a FormArray
   */
  get formArray(): FormArray | null {
    const control = this.formControl();
    return control instanceof FormArray ? control : null;
  }

  /**
   * Gets the subform configuration from the component config.
   * 
   * @returns The FormConfig for subform items, or null if not configured
   */
  get subformConfig(): FormConfig | null {
    const config = this.config();
    return (config?.formConfig as FormConfig | undefined) || null;
  }

  /**
   * Gets all FormGroup instances in the FormArray.
   * 
   * @returns Array of FormGroup controls representing subform items
   */
  get formGroups(): FormGroup[] {
    const array = this.formArray;
    return array ? (array.controls as FormGroup[]) : [];
  }

  /**
   * Gets the component type for a field from the registry.
   * 
   * @param field - The field configuration
   * @returns The component class, or null if not found
   */
  getFieldComponentType(field: FormField): Type<unknown> | null {
    return this.registry.get(field.type);
  }

  /**
   * Gets a field control from a form group.
   * 
   * @param formGroup - The form group containing the field
   * @param fieldName - The name of the field
   * @returns The AbstractControl instance, or null if not found
   */
  getFieldControl(formGroup: FormGroup, fieldName: string): AbstractControl | null {
    return formGroup.get(fieldName) || null;
  }

  /**
   * Checks if a field in a form group is invalid and touched.
   * 
   * @param formGroup - The form group containing the field
   * @param fieldName - The name of the field to check
   * @returns True if the field is invalid and touched, false otherwise
   */
  isFieldInvalid(formGroup: FormGroup, fieldName: string): boolean {
    const control = this.getFieldControl(formGroup, fieldName);
    return !!(control && control.invalid && control.touched);
  }

  /**
   * Gets the description string for a subform item.
   * 
   * Uses the configured `getItemDescription` function to generate a display
   * string for the item. Falls back to a default format if no function is provided.
   * 
   * @param formGroup - The FormGroup representing the item
   * @param index - The index of the item in the array
   * @returns Description string for the item
   */
  getItemDescription(formGroup: FormGroup, index: number): string {
    const config = this.config();
    if (config.getItemDescription) {
      return config.getItemDescription(formGroup, index);
    }
    return `Item ${index + 1}`;
  }

  /**
   * Checks if a new item can be added to the array.
   * 
   * Returns false if the maxItems constraint would be violated by adding
   * another item. Always returns true if no maxItems constraint is set.
   * 
   * @returns True if an item can be added, false otherwise
   */
  canAddItem(): boolean {
    const array = this.formArray;
    if (!array) {
      return true;
    }
    const config = this.config();
    if (config.maxItems !== undefined) {
      return array.length < config.maxItems;
    }
    return true;
  }

  /**
   * Checks if an item can be deleted from the array.
   * 
   * Returns false if:
   * - Deletion is explicitly disabled (allowDelete === false)
   * - The minItems constraint would be violated by deleting an item
   * 
   * @returns True if an item can be deleted, false otherwise
   */
  canDeleteItem(): boolean {
    const array = this.formArray;
    if (!array) {
      return false;
    }
    const config = this.config();
    if (config.allowDelete === false) {
      return false;
    }
    if (config.minItems !== undefined) {
      return array.length > config.minItems;
    }
    return array.length > 0;
  }

  /**
   * Opens a dialog to add a new item to the subform array.
   * 
   * When the dialog is closed with a valid FormGroup, the item is added to
   * the FormArray. The operation is scheduled asynchronously to avoid change
   * detection issues.
   */
  addItem(): void {
    const array = this.formArray;
    if (!array || !this.canAddItem()) {
      return;
    }

    const subformConfig = this.subformConfig;
    if (!subformConfig) {
      return;
    }

    const config = this.config();
    const dialogData: SubformItemDialogData = {
      formGroup: null,
      formConfig: subformConfig,
      title: config.addButtonLabel || 'Add Item'
    };

    const dialogRef = this.dialog.open(SubformItemDialogComponent, {
      width: '600px',
      data: dialogData
    });

    dialogRef.afterClosed().pipe(
      observeOn(asyncScheduler)
    ).subscribe(result => {
      if (result && result instanceof FormGroup) {
        array.push(result);
        array.updateValueAndValidity();
        this.cdr?.detectChanges();
      }
    });
  }

  /**
   * Opens a dialog to edit an existing item in the subform array.
   * 
   * The dialog is pre-filled with the current item's values. When the dialog
   * is closed with a valid FormGroup, the item at the specified index is updated.
   * The operation is scheduled asynchronously to avoid change detection issues.
   * 
   * @param index - The index of the item to edit
   */
  editItem(index: number): void {
    const array = this.formArray;
    if (!array || index < 0 || index >= array.length) {
      return;
    }

    const subformConfig = this.subformConfig;
    if (!subformConfig) {
      return;
    }

    const formGroup = array.at(index) as FormGroup;
    const config = this.config();
    const dialogData: SubformItemDialogData = {
      formGroup: formGroup,
      formConfig: subformConfig,
      title: 'Edit Item'
    };

    const dialogRef = this.dialog.open(SubformItemDialogComponent, {
      width: '600px',
      data: dialogData
    });

    dialogRef.afterClosed().pipe(
      observeOn(asyncScheduler)
    ).subscribe(result => {
      if (result && result instanceof FormGroup) {
        array.setControl(index, result);
        array.updateValueAndValidity();
        this.cdr?.detectChanges();
      }
    });
  }

  /**
   * Deletes an item from the subform array.
   * 
   * If confirmation is enabled (default), shows a confirmation dialog before
   * deletion. The operation is scheduled asynchronously to avoid change
   * detection issues.
   * 
   * @param index - The index of the item to delete
   */
  deleteItem(index: number): void {
    const array = this.formArray;
    if (!array) {
      return;
    }

    if (!this.canDeleteItem()) {
      return;
    }

    if (index < 0 || index >= array.length) {
      return;
    }

    const config = this.config();
    const itemDescription = this.getItemDescription(array.at(index) as FormGroup, index);
    
    if (config.confirmDelete !== false) {
      const message = config.deleteConfirmationMessage || 
        `Are you sure you want to delete "${itemDescription}"?`;
      
      if (!confirm(message)) {
        return;
      }
    }

    of(null).pipe(
      observeOn(asyncScheduler),
      tap(() => {
        array.removeAt(index);
        array.updateValueAndValidity();
        this.cdr?.detectChanges();
      })
    ).subscribe();
  }

  /**
   * Handles drag and drop reordering of items in the FormArray.
   * 
   * This method is called by Angular CDK when an item is dropped. It moves
   * the FormGroup from its previous position to the new position in the array.
   * 
   * @param event - The CDK drag drop event containing previous and current indices
   */
  dropItem(event: CdkDragDrop<FormGroup[]>): void {
    const array = this.formArray;
    if (!array) {
      return;
    }

    const config = this.config();
    if (config.allowDragDrop === false) {
      return;
    }

    const previousIndex = event.previousIndex;
    const currentIndex = event.currentIndex;

    if (previousIndex !== currentIndex) {
      const formGroup = array.at(previousIndex) as FormGroup;
      
      array.removeAt(previousIndex);
      array.insert(currentIndex, formGroup);
      array.updateValueAndValidity();
      
      if (this.cdr) {
        this.cdr.detectChanges();
      }
    }
  }

  /**
   * Creates a FormGroup from a FormConfig.
   * 
   * This helper method is used internally to create form groups for subform items.
   * It creates the appropriate form controls based on each field's control type.
   * 
   * @param config - The form configuration to create a FormGroup from
   * @returns A new FormGroup instance
   */
  private createFormGroupFromConfig(config: FormConfig): FormGroup {
    const formControls: Record<string, AbstractControl> = {};

    for (const field of config.fields) {
      const componentType = this.registry.get(field.type);
      if (!componentType) {
        continue;
      }

      const controlType = this.registry.getControlType(field.type);
      if (!controlType) {
        formControls[field.name] = this.fb.control(null);
        continue;
      }

      formControls[field.name] = this.createControlByType(controlType);
    }

    return this.fb.group(formControls);
  }

  /**
   * Creates a form control instance based on the specified control type.
   * 
   * @param controlType - The type of control to create
   * @returns A new FormControl, FormGroup, or FormArray instance
   */
  private createControlByType(controlType: ControlType): AbstractControl {
    switch (controlType) {
      case 'control':
        return this.fb.control(null);
      case 'group':
        return this.fb.group({});
      case 'array':
        return this.fb.array([]);
      default:
        return this.fb.control(null);
    }
  }

  /**
   * Initializes the component and applies validators to the FormArray.
   * 
   * This method sets up validation rules including:
   * - Required validator (if field is marked as required)
   * - MinItems validator (if minItems is specified in config)
   * - MaxItems validator (if maxItems is specified in config)
   * - Custom validators (if provided in field.validators)
   */
  ngOnInit(): void {
    const validators: ValidatorFn[] = [];
    const field = this.field();
    const config = this.config();

    if (field.required === true) {
      validators.push(Validators.required);
    }

    if (config.minItems !== undefined) {
      validators.push((control: AbstractControl) => {
        const array = control as FormArray;
        if (array.length < config.minItems!) {
          return { minItems: { required: config.minItems, actual: array.length } };
        }
        return null;
      });
    }

    if (config.maxItems !== undefined) {
      validators.push((control: AbstractControl) => {
        const array = control as FormArray;
        if (array.length > config.maxItems!) {
          return { maxItems: { required: config.maxItems, actual: array.length } };
        }
        return null;
      });
    }

    if (field.validators) {
      if (Array.isArray(field.validators)) {
        validators.push(...field.validators);
      } else {
        validators.push(field.validators);
      }
    }

    const control = this.formControl();
    if (control && validators.length > 0) {
      control.setValidators(validators);
      control.updateValueAndValidity();
    }
  }
}
